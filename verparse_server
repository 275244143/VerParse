#!/usr/bin/perl -w

# Copyright information contained at the end of the file

# Import Modules
use Getopt::Long;
use Pod::Usage;
use Verilog::Netlist;
use Verilog::Getopt;
use Verilog::Preproc;
use IO::Socket;
use strict;

# Set global variables for 'use strict'
use vars qw ( $Debug $socketFile $socketDir $socket $opt
              $nl $pp $com $recData %recDataHash $sendData
);

# Set global variables
$Debug = 0;
%recDataHash = ();
$socketDir = $ENV{'VERPARSE_SOCKET'};
    # See if the $sockedDir environment variable has been set, if not, exit
    die "The VERPARSE_SOCKET environment variable isn't set! Exitting..." unless $socketDir;

$socketFile = "$socketDir/socket";

# Prevent an INT signal (CTRL-C) from killing the program without removing the socket file
$SIG{INT} = \&interrupt_handler;

# Setup communication port
createSocket();

# Get command line options
$opt = new Verilog::Getopt();

@ARGV = $opt->parameter(@ARGV);
# print "Included extensions  :", $opt->libext(), "\n"; #debug
# print "Included directories :", $opt->incdir(), "\n"; #debug
# print "Included module directories :", $opt->module_dir(), "\n"; #debug
# print "Included files       :", $opt->library(), "\n"; #debug

if (! GetOptions (
          "help"    => \&usage,
          "debug"   => \&debug,
          "<>"      => \&parameter,
    )) {
    die "%Error: Bad usage, try 'vnetsearch --help'\n";
}

print "Using UNIX domain socket $socketFile\n";

# Build the Verilog::Netlist object
buildNetlist();

# Main program loop
# Wait for and process requests from the client
while (1) {

    # Accept incoming connections
    $com = $socket->accept() or die("Can't accept connection: $!\n");

    # Wait until a newline character is received to process the data
    chomp ( $recData = <$com> );

    # Decipher $recData and issue commands
    print qq{\n******************************\nClient has sent command: "$recData"\n} if $Debug;

    # Split data into a hash to find commands easily
    %recDataHash = split(/[=;]/, $recData);

    # Send INT signal if kill requested
    if (exists $recDataHash{kill}) {
        print $com "Server killed, INT signal received from client\n";
        interrupt_handler();
    }

    # Reload netlist if refresh requested
    if (exists $recDataHash{refresh}) {
        buildNetlist();
        print "Netlist object refreshed on verparse_server\n" if $Debug;
        print $com "Netlist object refreshed on verparse_server\n";
        # Clear the data hash and return to top of while loop
        %recDataHash = ();
        next;
    }

    # Pass client data on to parsing subroutines and return result
    my @returnData;
    my @inputData;

    my $searchString = $recDataHash{search};
    my $fileString   = $recDataHash{file};

    $inputData[0] = $searchString;
    $inputData[1] = $fileString if exists $recDataHash{file};
    print "Input data: $inputData[0]\n" if $Debug;

    # Search for define value
    @returnData = defineValue(@inputData) if $recDataHash{type} eq "define";

    # Search for the declaration of a net or register
    @returnData =  findSignal(@inputData) if $recDataHash{type} eq "signal";

    # Search for a module declaration
    @returnData =  findModule(@inputData) if $recDataHash{type} eq "module";

    # Trace the load of a net or register
    @returnData =  traceLoads(@inputData) if $recDataHash{type} eq "trace";

    # Send data to client
    $sendData = join(' ', @returnData);
    print "Server returned data: $sendData\n" if $Debug;
    print $com "$sendData\n";

    # Clear hash to process next client request
    %recDataHash = ();
}

######################################################################

# Interrupt handler

sub interrupt_handler {
    print "\nClosing verparse_server socket in $socketFile\n\nExitting...\n";
    $socket->close();
    unlink $socketFile;
    $nl->delete;
    exit(1);
}

######################################################################

# Display POD

sub usage {
    pod2usage(-verbose=>2, -exitval=> 2);
    exit (1);
}

######################################################################

# Enable debug output

sub debug {
    $Debug = 1;
}

######################################################################

# Setup UNIX domain socket

sub createSocket {
    
    # Check and see if the UNIX domain socket file exists, if not, create one
    unless (-S $socketFile) {
        $socket = IO::Socket::UNIX->new(Local     => $socketFile,
                                        Type      => SOCK_STREAM,
                                        Listen    => SOMAXCONN
                                       ) or die ( "Can't create server socket: $!\n");
        
    } else {
        print "Server already running...\n";
        exit (1);
    }
}

######################################################################

# Build the Verilog::Netlist object and setup the preprocessor

sub buildNetlist {
    # Delete an existing netlist object before a refresh
    $nl->delete if $nl;
        
    # Create new netlist object
    $nl = new Verilog::Netlist (options => $opt,
                                keep_comments => 0,
                                use_vars => 1,
                                implicit_wires_ok => 1,
                                include_open_nonfatal => 1
                               );

    # Read in all modules
    $nl->read_libraries();

    # Read the files in the project and create full netlist tree
    print "\nRead in the following project files:\n\n" if $Debug;
    for my $fileHash ($nl->files) {
        my $fileName = $fileHash->name;
        print "$fileName\n" if $Debug;
        $nl->read_file ( filename => $fileName );
    }

    $nl->link();
    #$nl->lint();  #This checks for lint warnings on pins. slows it down, may implement later
    $nl->exit_if_error();

    $pp = Verilog::Preproc->new(keep_comments         => 0, # Remove all comments
                                keep_whitespace       => 0, # Convert all whitespace to either a newline or single space
                                include_open_nonfatal => 1, # Ignore any include files that do not exist
                                options             => $opt # Pass all verilog options in order to resolve filenames and defines
                                  );

    #print $nl->verilog_text if $Debug; #Print out the verilog code representing the netlist. Could be useful in a major debug

}

######################################################################

# Find the root definition of a net or register

sub findSignal {
    # Pull in arguments
    my $search   = $_[0];
    my $filename = $_[1];

    # Setup parsing regular expression. Searches for the following lines in a file:
    #
    # assign netName = ******
    # assign netName[1:0] = ******
    # assign {******netName[1:0]******} =
    #   regName <= ******
    #   regName = ******
    #   regName[1:0] <= ******
    #   regName[1:0] = ******
    #   {******regname******} = ******
    #   if (******) regname <= ******
    # 
    # Regular expression: /^\s?((assign\s$netName[\s\[\=\{])|(.*\([\w\s:]+\)[^<=]*$netName)|([\{]?$netName[\s\[\,\<\=].*[\&\|;])|(\{.*\,\s?$netName[\s\[\}\,]))/

    # Search each module for the requested signal
    print "Net search command issued:\n" if $Debug;

    # If a filename is given, search the given filename first, then parse connected modules for the signal declaration
    if ($filename) {
        # From the filename given, determine the current module (this only works if the basename of the file matches the module name
        # e.g. filename is "module_1.v" and the module is called "module_1")
        my $fileref = $nl->read_file( filename => $filename );
        my $moduleName  = $fileref->basename;

        print "Module name: $moduleName\n" if $Debug;

        if ($moduleName) {
            my $module = $nl->find_module($moduleName);
            my $port = '';

            # Iterate through connected modules until the signal declaration is found
            while (1) {
                # Check to see if the net is a port to the module
                if ($module->find_port($search)) {
                    $port = $module->find_port($search);
                } else {
                    $port = '';
                }

                #print "Port name: ", $port->name, "\n" if $Debug;

                # If the port does not exist or is an output the declaration must be in the local module or leaf cell
                if ($port eq '') {
#                    # Check leaf cells and see if this signal is an output
#                    for my $leafCell ($module->cells) {
#                        for my $leafPin ($leafCell->pins) {
#                            my $leafNet = $leafPin->net;
#                            if ($leafNet->name eq $search) {
#                                $module = $leafCell->submod;
#                                $search = $leafPin->name;
#                                next;
#                            }
#                        }
#                    }
                    
                    my @returnData;
                    @returnData = parseModuleForNet($search, $module);
                    if ($returnData[0]) {
                        return @returnData;
                    }
                } else {
                    if ($port->direction eq "out") {
#                        # Check leaf cells and see if this signal is an output
#                        for my $leafCell ($module->cells) {
#                            for my $leafPin ($leafCell->pins) {
#                                my $leafNet = $leafPin->net;
#                                if ($leafNet->name eq $search) {
#                                    $module = $leafCell->submod;
#                                    $search = $leafPin->name;
#                                    next;
#                                }
#                            }
#                        }

                        my @returnData;
                        @returnData = parseModuleForNet($search, $module);
                        if ($returnData[0]) {
                            return @returnData;
                        }

                        # If the port is an input, go to the instantiating module
                    } elsif ($port->direction eq "in") {
                        # Parse through the other modules and find which instantiate this module
                        my @moduleArray;
                        my @cellArray;
                        my $inc = 0;
                        my $cell = '';
                        for my $upModule ($nl->modules) {
                            for my $upCell ($upModule->cells) {
                                if ($upCell->submodname eq $module->name) {
                                    $moduleArray[$inc] = $upModule;
                                    $cellArray[$inc]   = $upCell;
                                }
                            }
                        }
                        
                        # Find the array size
                        my $size = @moduleArray;
                        $cell = $cellArray[0];

                        print "Cell Name: ", $cell->name, "\n" if $Debug;
                        
                        # If only one module instantiates this cell, go into that module and search again
                        if ( $size == 1 ) {
                            # Get the pin in this cell and get the name of the net connected to it
                            my $pin = $cell->find_pin($search);
                            my $moduleNet = $pin->net;
                            $search = $moduleNet->name;

                            # Get the name of the module this is in
                            $module = $cell->module;
                            print "Up-Module Name: ", $module->name, "\n" if $Debug;

                            # If several modules instantiate this cell, return all instantiating modules files' and the line number where the search stopped
                        } elsif ( $size > 1 ) {


                        } else {
                            # If subroutine gets to this point, the net was not found
                            print "Searched signal not found\n" if $Debug;
                            return;
                        }
                    }
                }
            }
        }
    } else {

        # If no filename is given, go through every module and search for the signal declaration (can be very slow depending on project size
        # and does not detect signal renames across module boundaries)
        #print "\nLoaded Modules with containing nets:\n\n" if $Debug;
        for my $module ($nl->modules) {
            #print $module->name, "\n" if $Debug; #Print all loaded modules
            my $foundNet = $module->find_net ($search);
            if ($foundNet) {
                my @returnData;
                @returnData = parseModuleForNet($search, $module);
                if ($returnData[0]) {
                    return @returnData;
                }
            }
        }
    }

    # If subroutine gets to this point, the net was not found
    print "Searched signal not found\n" if $Debug;
    return;
}

sub parseModuleForNet {
    # Pass parameters
    my $netName = $_[0];
    my $module  = $_[1];

    $pp->open(filename => $nl->resolve_filename($module->name));
    while (defined ( my $line = $pp->getline())) {
        if ( $line =~ /^\s?((assign\s$netName[\s\[\=\{])|(.*\([\w\s:]+\)[^<=]*$netName)|([\{]?$netName[\s\[\,\<\=].*[\&\|;])|(\{.*\,\s?$netName[\s\[\}\,]))/ ) {
            print "Found definition of $netName in file ", $nl->resolve_filename($module->name), " on line ", $pp->lineno(), "\n" if $Debug;
            my $returnFile = $nl->resolve_filename($module->name);
            my $returnLine = $pp->lineno();
            my @returnData = ($returnFile, $returnLine);
            return @returnData;
        }
    }
}

######################################################################

# Find the root definition of a module

sub findModule {
    # Pull in arguments
    my $search   = $_[0];

    print "Module declaration search command issued:\n" if $Debug;

    #Parse the Verilog::Netlist object for the file and line number of the module declaration
    my $foundModule = $nl->find_module($search);
    my $returnFile  = $nl->resolve_filename($foundModule->name);

    $pp->open(filename => $returnFile);
    while (defined ( my $line = $pp->getline())) {
        if ( $line =~ /^\s?module\s$search[\s\(]/ ) {
            my $returnLine = $pp->lineno();
            print "Found declaration of $search in file $returnFile on line $returnLine\n" if $Debug;
            return ($returnFile, $returnLine);
        }
    }

    # If subroutine gets to this point, the net was not found
    print "Module not found\n" if $Debug;
    return;

}

######################################################################

# Find and return the value of a define

sub defineValue {
    # Pull in arguments
    my $search   = $_[0];

    print "Display define value command issued:\n" if $Debug;

    #Parse the Verilog::Netlist object for the define value
    my $foundDefine = $nl->defvalue_nowarn($search);

    return $foundDefine if $foundDefine;

    # If subroutine gets to this point, the define was not found
    return;

}

######################################################################

# Trace the loads of the given signal

sub traceLoads {

}

######################################################################
######################################################################
######################################################################

__END__

=pod

=head1 NAME

verparse_server - Setup a server to be used in connection with the
client program (see L<verparse>)

=head1 SYNOPSIS

  verparse_server --help
  verparse_server [verilog_options] [--debug]

=head1 DESCRIPTION

verparse_server uses the Verilog::Netlist perl module to build a netlist of the project.
It also sets up a UNIX domain socket in order to process search requests from the client
program L<verparse>

=head1 DISTRIBUTION

Verilog-Perl is part of the L<http://www.veripool.org/> free Verilog EDA
software tool suite. The latest version is availabe from CPAN and from
L<http://www.veripool.org/verilog-perl>.

Copyright 2011 by Chuck McClish. This package is free software; you
can redistribute it and/or modify it under the terms of either the GNU
Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.

=head1 AUTHOR

Chuck McClish <charles.mcclish@microchip.com>

=head1 SEE ALSO

L<Verilog-Perl>,
L<Verilog::Getopt>,
L<Verilog::Netlist>,
L<IO::Socket>

=cut
######################################################################
