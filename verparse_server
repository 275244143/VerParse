#!/usr/bin/perl -w

# Copyright information contained at the end of the file

# Import Modules
use Getopt::Long;
use Pod::Usage;
use Verilog::Netlist;
use Verilog::Getopt;
use Verilog::Preproc;
use IO::Socket;
use strict;

# Set global variables for 'use strict'
use vars qw ( $Debug $socketFile $socketDir $socket $opt
              $nl $pp $com
);

# Set global variables
$Debug = 0;
$socketDir = $ENV{'VERPARSE_SOCKET'};
    # See if the $sockedDir environment variable has been set, if not, exit
    die "The VERPARSE_SOCKET environment variable isn't set! Exitting..." unless $socketDir;

$socketFile = "$socketDir/socket";

# Prevent an INT signal (CTRL-C) from killing the program without removing the socket file
$SIG{INT} = \&interrupt_handler;

# Setup communication port
createSocket();

# Get command line options
$opt = new Verilog::Getopt();

@ARGV = $opt->parameter(@ARGV);
# print "Included extensions  :", $opt->libext(), "\n"; #debug
# print "Included directories :", $opt->incdir(), "\n"; #debug
# print "Included module directories :", $opt->module_dir(), "\n"; #debug
# print "Included files       :", $opt->library(), "\n"; #debug

if (! GetOptions (
          "help"    => \&usage,
          "debug"   => \&debug,
          "<>"      => \&parameter,
    )) {
    die "%Error: Bad usage, try 'vnetsearch --help'\n";
}

print "Using UNIX domain socket $socketFile\n\n";

# Build the Verilog::Netlist object
buildNetlist();

# Start the server
#$com = $socket->accept();

# Main program loop
# Wait for and process requests from the client
while (1) {
    
}

######################################################################

# Interrupt handler

sub interrupt_handler {
    print "\nClosing verparse_server socket in $socketFile\n\nExitting...\n";
    $socket->close();
    unlink $socketFile;
    exit(1);
}

######################################################################

# Display POD

sub usage {
    pod2usage(-verbose=>2, -exitval=> 2);
    exit (1);
}

######################################################################

# Enable debug output

sub debug {
    $Debug = 1;
}

######################################################################

# Setup UNIX domain socket

sub createSocket {
    
    # Check and see if the UNIX domain socket file exists, if not, create one
    #unlink $socketFile;
    unless (-S $socketFile) {
        $socket = IO::Socket::UNIX->new(Local     => $socketFile,
                                        Type      => SOCK_DGRAM,
                                        Listen    => 32
                                       ) or die $!;

        $socket->autoflush(1);
    } else {
        print "Server already running...\n";
        exit (1);
    }
}

######################################################################

# Build the Verilog::Netlist object and setup the preprocessor

sub buildNetlist {

    # Create new netlist object
    $nl = new Verilog::Netlist (options => $opt,
                                keep_comments => 0,
                                use_vars => 1,
                                implicit_wires_ok => 1,
                                include_open_nonfatal => 1
                               );

    # Read in all modules
    $nl->read_libraries();

    # Read the files in the project and create full netlist tree
    print "\nRead in the following project files:\n\n" if $Debug;
    for my $fileHash ($nl->files) {
        my $fileName = $fileHash->name;
        print "$fileName\n" if $Debug;
        $nl->read_file ( filename => $fileName );
    }

    $nl->link();
    #$nl->lint();  #This checks for lint warnings on pins. slows it down, may implement later
    $nl->exit_if_error();

    $pp = Verilog::Preproc->new(keep_comments => 0,
                                   options => $opt
                                  );

    #print $nl->verilog_text if $Debug; #Print out the verilog code representing the netlist. Could be useful in a major debug

#    # Search each module for the requested signal
#    print "\nLoaded Modules with containing nets:\n\n" if $Debug;
#    for my $module ($nl->modules) {
#        print $module->name, "\n" if $Debug; #Print all loaded modules
#        my $foundNet = $module->find_net ($searchString);
#        if ($foundNet) {
#            my $netName = $foundNet->name;
#            $pp->open(filename => $nl->resolve_filename($module->name));
#            while (defined ( my $line = $pp->getline())) {
#                # This regular expression is the guts of the parsing routine. This will expand greatly
#                if ( $line =~ /^\s*assign\s+$netName\s+/ ) {
#                    print "Found definition of: $netName in file ", $nl->resolve_filename($module->name), " on line ", $pp->lineno(), "\n" if $Debug;
#                    print $nl->resolve_filename($module->name), " ", $pp->lineno(), "\n";
#                }
#            }
#        }
#        for my $netHash ($module->nets) {
#            print "  ", $netHash->name, "\n" if $Debug; #Print all nets
#        }
#        
#    }

}

######################################################################

# Find the root definition of a net or register

sub findSignal {

}

######################################################################

# Find the root definition of a module

sub findModule {

}

######################################################################

# Find the value of a parameter or define

sub paramValue {

}

######################################################################

# Trace the loads of the given signal

sub traceLoads {

}

######################################################################
######################################################################
######################################################################

__END__

=pod

=head1 NAME

verparse_server - Setup a server to be used in connection with the
client program (see L<verparse>)

=head1 SYNOPSIS

  verparse_server --help
  verparse_server [verilog_options] [--debug]

=head1 DESCRIPTION

verparse_server uses the Verilog::Netlist perl module to build a netlist of the project.
It also sets up a UNIX domain socket in order to process search requests from the client
program L<verparse>

=head1 DISTRIBUTION

Verilog-Perl is part of the L<http://www.veripool.org/> free Verilog EDA
software tool suite. The latest version is availabe from CPAN and from
L<http://www.veripool.org/verilog-perl>.

Copyright 2011 by Chuck McClish. This package is free software; you
can redistribute it and/or modify it under the terms of either the GNU
Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.

=head1 AUTHOR

Chuck McClish <charles.mcclish@microchip.com>

=head1 SEE ALSO

L<Verilog-Perl>,
L<Verilog::Getopt>,
L<Verilog::Netlist>,
L<IO::Socket>

=cut
######################################################################
